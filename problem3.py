#  После описания функций идет описания подхода к решению задачи
# в виде комментариев!

import copy
from collections import deque
import random


def randomword(length):
    """Функция для генерации случайно строки из 0 и 1.
    Используется для теста игры Алго ИИ на случайном вводе(отладка и
    оценка стратегии).

    Parameters
    ----------
    length : int
        длинна генерируемой строки в символах

    Returns
    -------
    python string
        сгенерированная строка из случайного набора 0 и 1
    """
    letters = ['0', '1']
    return ''.join(random.choice(letters) for i in range(length))


def print_field(field):
    """Функция печатает игровое поле (удобна для отладки и визуализации
    игры Алго ИИ) в виде:

    [1, 1, 1, 0]
    [1, 0, 0, 0]
    [0, 0, 0, 0]
    [0, 0, 0, 0]

    0 - без кирпича, 1 - место занятое кирпичами

    Parameters
    ----------
    field : list of lists
        Двумерный массив, представляющий собой игровое поле.
    """
    for row in field:
        print(row)
    print()


def check_rows_for_full(field, rows, count):
    """Проверяем игровое поле на наличие строк состоящих полностью из 1-ц
    (полностью заполнен кирпичами).
    Необходимо для подсчета баллов(по одному за очищенный ряд игрового поля)
    и очистки поля.

    Parameters
    ----------
    field : list of lists
        Двумерный массив, представляющий собой игровое поле в виде

        [1, 1, 1, 0]
        [1, 0, 0, 0]
        [0, 0, 0, 0]
        [0, 0, 0, 0]

        0 - без кирпича, 1 - место занятое кирпичами

    rows : tuple
        кортеж из номеров строк игрового поля, которые мы хоти проверить
        на заполненность 1-цами(полностью заполнен кирпичами).
    count : int
        число уже имеющихся баллов (по одному за очищенный ряд или столбец
        игрового поля)

    Returns
    -------
    field : list of lists
        Двумерный массив, представляющий собой очищенное игровое поле.

    count : int
        обновленное число баллов (по одному за очищенный ряд или столбец
        игрового поля)
    """
    for row in rows:
        if sum(field[row]) == 4:
            # зануляем ряд
            field[row] = [0] * 4
            count += 1

    return field, count


def check_cols_for_full(field, cols, count):
    """Проверяем игровое поле на наличие столбцов состоящих полностью из 1-ц
    (полностью заполнен кирпичами).
    Необходимо для подсчета баллов(по одному за очищенный столбец игрового
    поля) и очистки поля.

    Parameters
    ----------
    field : list of lists
        Двумерный массив, представляющий собой игровое поле в виде

        [1, 1, 1, 0]
        [1, 0, 0, 0]
        [0, 0, 0, 0]
        [0, 0, 0, 0]

        0 - без кирпича, 1 - место занятое кирпичами

    cols : tuple
        кортеж из номеров столбцов игрового поля, которые мы хоти проверить
        на заполненность 1-цами(полностью заполнен кирпичами). 

    count : int
        число уже имеющихся баллов (по одному за очищенный ряд или столбец
        игрового поля)

    Returns
    -------
    field : list of lists
        Двумерный массив, представляющий собой очищенное игровое поле в виде

    count : int
        обновленное число баллов (по одному за очищенный ряд или столбец
        игрового поля)
    """
    for col in cols:
        summa = 0
        for row in range(0, 4):
            summa += field[row][col]

        if summa == 4:
            # зануляем столбец
            for row in range(0, 4):
                field[row][col] = 0
            count += 1

    return field, count


def check_can_place_horiz_break(field, row, col):
    """Функция проверяет можем ли мы установить горизонтальный кирпичик
    в позицию (row, col) игрового поля.

    Parameters
    ----------
    field : list of lists
        Двумерный массив, представляющий собой игровое поле в виде

        [1, 1, 1, 0]
        [1, 0, 0, 0]
        [0, 0, 0, 0]
        [0, 0, 0, 0]

        0 - без кирпича, 1 - место занятое кирпичами

    row : int
        номер минимальной строки игрового поля, позиции в которую будет
        установлен горизонтальный кирпичик

    col : int
        номер минимального столбца игрового поля, позиции в которую будет
        установлен горизонтальный кирпичик

    Returns
    -------
    status : bool
        статус проверки, показывает возможность размещения горизонтального
        кирпича в позицию (row, col) игрового поля.
        True или 1 - кирпич можно разместить.
        False или 0 - кирпич нельзя разместить.

    count : int
        число баллов которое мы получим за размещение кирпичика в позицию
        (row, col) игрового поля (по одному за очищенный ряд или столбец
        игрового поля).
    """
    row, col = row - 1, col - 1
    status = 0
    count = 0

    try:
        if field[row][col+1] == 0 and field[row][col] == 0:
            status = 1
            tmp_field = copy.deepcopy(field)
            tmp_field[row][col+1] = 1
            tmp_field[row][col] = 1
            tmp_field, count = check_rows_for_full(tmp_field, (row,), count)
            tmp_field, count = check_cols_for_full(
                tmp_field, (col, col+1), count)

    except:
        pass

    return status, count


def place_horiz_break(field, row, col, check_full=False):
    """Функция устанавливает горизонтальный кирпичик в позицию (row, col)
    игрового поля.

    Parameters
    ----------
    field : list of lists
        Двумерный массив, представляющий собой игровое поле в виде

        [1, 1, 1, 0]
        [1, 0, 0, 0]
        [0, 0, 0, 0]
        [0, 0, 0, 0]

        0 - без кирпича, 1 - место занятое кирпичами

    row : int
        номер минимальной строки игрового поля, позиции в которую будет
        установлен горизонтальный кирпичик

    col : int
        номер минимального столбца игрового поля, позиции в которую будет
        установлен горизонтальный кирпичик

    check_full : bool, optional
        нужно ли выполнить проверку игрового поля на возможность очистки
        от полностью заполненных строк и столбцов ?, by default False.
        Когда мы устанавливаем кирпичик, мы уже знаем сколько строк или столбов
        нужно очистить. Если очищать не нужно, число баллов = 0, то не 
        выполняем проверку.

    Returns
    -------
    field : list of lists
        Двумерный массив, представляющий собой очищенное игровое поле.
    """
    row, col = row - 1, col - 1
    field[row][col+1] = 1
    field[row][col] = 1

    if check_full:
        field, count = check_rows_for_full(field, (row,), count=0)
        field, count = check_cols_for_full(field, (col, col+1), count=0)

    return field


def check_can_place_vert_break(field, row, col):
    """Функция проверяет можем ли мы установить вертикальный кирпичик
    в позицию (row, col) игрового поля.

    Parameters
    ----------
    field : list of lists
        Двумерный массив, представляющий собой игровое поле в виде

        [1, 1, 1, 0]
        [1, 0, 0, 0]
        [0, 0, 0, 0]
        [0, 0, 0, 0]

        0 - без кирпича, 1 - место занятое кирпичами

    row : int
        номер минимальной строки игрового поля, позиции в которую будет
        установлен вертикальный кирпичик

    col : int
        номер минимального столбца игрового поля, позиции в которую будет
        установлен вертикальный кирпичик

    Returns
    -------
    status : bool
        статус проверки, показывает возможность размещения вертикального
        кирпича в позицию (row, col) игрового поля.
        True или 1 - кирпич можно разместить.
        False или 0 - кирпич нельзя разместить.

    count : int
        число баллов которое мы получим за размещение кирпичика в позицию
        (row, col) игрового поля (по одному за очищенный ряд или столбец
        игрового поля).
    """
    row, col = row - 1, col - 1
    status = 0
    count = 0

    try:
        if field[row+1][col] == 0 and field[row][col] == 0:
            status = 1
            tmp_field = copy.deepcopy(field)
            tmp_field[row+1][col] = 1
            tmp_field[row][col] = 1
            tmp_field, count = check_rows_for_full(
                tmp_field, (row, row+1), count)
            tmp_field, count = check_cols_for_full(tmp_field, (col,), count)
    except:
        pass

    return status, count


def place_vert_break(field, row, col, check_full=False):
    """Функция устанавливает вертикальный кирпичик в позицию (row, col)
    игрового поля.

    Parameters
    ----------
    field : list of lists
        Двумерный массив, представляющий собой игровое поле в виде

        [1, 1, 1, 0]
        [1, 0, 0, 0]
        [0, 0, 0, 0]
        [0, 0, 0, 0]

        0 - без кирпича, 1 - место занятое кирпичами

    row : int
        номер минимальной строки игрового поля, позиции в которую будет
        установлен вертикальный кирпичик

    col : int
        номер минимального столбца игрового поля, позиции в которую будет
        установлен вертикальный кирпичик

    check_full : bool, optional
        нужно ли выполнить проверку игрового поля на возможность очистки
        от полностью заполненных строк и столбцов ?, by default False.
        Когда мы устанавливаем кирпичик, мы уже знаем сколько строк или столбов
        нужно очистить. Если очищать не нужно, число баллов = 0, то не 
        выполняем проверку.

    Returns
    -------
    field : list of lists
        Двумерный массив, представляющий собой очищенное игровое поле.
    """
    row, col = row - 1, col - 1
    field[row+1][col] = 1
    field[row][col] = 1

    if check_full:
        field, count = check_rows_for_full(field, (row, row+1), count=0)
        field, count = check_cols_for_full(field, (col,), count=0)

    return field

# Я решаю данную задачу все возможным перебором позиций =)
# Мы считываем текущий кирпичик, и проверяем в какие позиции мы можем его
# поставить. У вертикального и горизонтального кирпичика всего 12 положений
# в которых он может быть на чистом игровом поле.
# При этом мы проверяем можно ли поставить кирпичик в данную позицию
# и получится ли при этом положении полные строки или полные столбцы очищающие
# поле. За каждый очищенный столбец или строку мы начиняем баллы.
# Обойдя все возможные позиции для текущего кирпичика мы узнаем
# выгодные положения очищающие максимум строк или столбцов и выбираем одно
# из них.
# Если таких нет, то просто любую позицию куда можно поставить текущий
# кирпичик.


# для себя я всегда печатал игровое поле после каждого хода
# сделанного Алго ИИ. Но при сдаче задачи печатать игровое поле не нужно.
is_debug = False

# для теста на случаиных входных данных
# input_string = randomword(1000)
# if is_debug:
#     print(input_string)

input_string = input()
input_breaks = deque(input_string)

# инициализируем игровое поле
# 0 - без кирпича, 1 - место занятое кирпичами
field = []
for row in range(4):
    field.append([0, 0, 0, 0])

# зададим все возможные позиции для вертикального кирпичика
vert_check_pos = []
for row in range(1, 4):
    for col in range(1, 5):
        vert_check_pos.append((row, col))

# зададим все возможные позиции для горизонтального кирпичика
horiz_check_pos = []
for row in range(1, 5):
    for col in range(1, 4):
        horiz_check_pos.append((row, col))


# запуск игры и нашего Алго ИИ
if is_debug:
    print_field(field)

while (len(input_breaks) != 0):
    cur_block = input_breaks.popleft()

    if cur_block == '0':
        # небезопасно, но код короче =)
        check_pos = vert_check_pos
        check_can_place_break = check_can_place_vert_break
        place_break = place_vert_break

    else:
        # небезопасно, но код короче =)
        check_pos = horiz_check_pos
        check_can_place_break = check_can_place_horiz_break
        place_break = place_horiz_break

    # будем хранить список доступных позиций для кирпичика и количество
    # балов (по одному за очищенный ряд или столбец игрового поля)
    # полученных при его размещении размещение в данную позицию
    # availible_pos = [ ( (row1, col1), count) ]
    availible_pos = []

    for pos in check_pos:
        row, col = pos
        status, count = check_can_place_break(field, row, col)
        if status:
            availible_pos.append(((row, col), count))

    # ищем доступную позицию с макс количеством баллов
    if not availible_pos:
        # доступных  позиций для размещения кирпичика нет
        # ИИ проиграл =(
        print('мы проиграли =(')
        break

    else:
        # находим лучшую позицию по баллам
        availible_pos.sort(key=lambda x: -x[1])
        best_pos = availible_pos[0]
        if is_debug:
            print(best_pos)

        # размещаем блок в лучшую позицию
        row, col = best_pos[0]
        count = best_pos[1]
        field = place_break(field, row, col, count)
        print(f'{row} {col}')

        if is_debug:
            print_field(field)
